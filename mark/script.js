// A. Ensure the webpage's structure (DOM) is fully loaded and ready before executing any JavaScript.
document.addEventListener("DOMContentLoaded", () => {
  // B. Define a custom extension for the 'marked' library to handle ==highlight== syntax.
  const highlightExtension = {
    // B.1. Name: A unique identifier for the extension.
    name: "highlight",
    // B.2. Level: Specifies that this rule operates on inline text (within paragraphs, etc.), not block-level elements (like entire paragraphs or code blocks).
    level: "inline",
    // B.3. Start Function: A quick check for 'marked' to see if the current text might contain the syntax. It returns the index if '==' is found, otherwise undefined.
    start(src) {
      return src.indexOf("==");
    },
    // B.4. Tokenizer Function: This function analyzes the source string ('src') to find and define the custom token if the pattern matches.
    //    - 'src': The portion of the Markdown source being processed.
    //    - 'tokens': A list of existing tokens (not used in this simple inline rule).
    tokenizer(src, tokens) {
      // B.4.a. Define the regular expression: Looks for '==' followed by one or more characters that are NOT '=', captured in group 1, and ending with '=='.
      const rule = /^==([^=]+)==/;
      // B.4.b. Attempt to match the regex at the beginning of the current source string.
      const match = rule.exec(src);
      // B.4.c. If a match is found:
      if (match) {
        // B.4.d. Return a token object describing the match.
        return {
          type: "highlight", // Matches the extension name.
          raw: match[0], // The full matched text (e.g., "==some text==").
          text: match[1].trim(), // The captured text inside the '==' (e.g., "some text"), with leading/trailing whitespace removed.
          tokens: [], // Child tokens, not needed for this simple inline element.
        };
      }
      // B.4.e. If no match is found, return undefined (or false) so 'marked' knows this rule doesn't apply here.
    },
    // B.5. Renderer Function: This function takes a token generated by the tokenizer and returns the corresponding HTML string.
    //    - 'token': The token object created by the tokenizer (e.g., { type: 'highlight', raw: '==text==', text: 'text' }).
    renderer(token) {
      // B.5.a. Generate the HTML: Wrap the token's text content in <mark> tags.
      return `<mark>${token.text}</mark>`;
    },
  };

  // C. Register the custom extension with the 'marked' library.
  marked.use({ extensions: [highlightExtension] });

  // D. Configure global options for the 'marked' library.
  marked.setOptions({
    // D.1. Highlight Function: Define how code blocks (```lang ... ```) should be processed for syntax highlighting.
    //    - 'code': The raw code string within the block.
    //    - 'lang': The language specified (e.g., 'javascript').
    highlight: function (code, lang) {
      // D.1.a. Determine the language for highlight.js. Check if the provided 'lang' is valid.
      const language = hljs.getLanguage(lang) ? lang : "plaintext";
      // D.1.b. Use highlight.js to apply syntax highlighting.
      //       - 'code': The code to highlight.
      //       - '{ language }': Specify the language.
      //       - '.value': Get the resulting HTML string with highlighting classes.
      return hljs.highlight(code, { language }).value;
    },
    // Other marked options like 'breaks: true' or 'gfm: true' could be added here if needed.
  });

  // E. Get references to the HTML elements used for input and output.
  const markdownInput = document.getElementById("markdown-content"); // The <textarea> for Markdown input.
  const htmlOutput = document.getElementById("html-preview"); // The <div> where HTML output is displayed.
  // F. Define a key for storing and retrieving the editor content from the browser's localStorage.
  const localStorageKey = "markdownEditorContent";

  // G. Define the function responsible for updating the HTML preview and saving the content.
  function updatePreviewAndSave() {
    // G.1. Get the current Markdown text from the input textarea.
    const markdownText = markdownInput.value;

    // G.2. Save the current Markdown text to localStorage.
    try {
      // Use the defined key to store the text. This persists the content even if the browser is closed.
      localStorage.setItem(localStorageKey, markdownText);
    } catch (e) {
      // Handle potential errors (e.g., localStorage is full or disabled).
      console.error("Could not save to localStorage:", e);
    }

    // G.3. Convert the Markdown text to HTML using the 'marked' library.
    //     This applies the standard Markdown rules plus our custom 'highlight' extension and code highlighting.
    const htmlContent = marked.parse(markdownText);

    // G.4. Sanitize the generated HTML using DOMPurify to prevent XSS attacks.
    const sanitizedHtml = DOMPurify.sanitize(htmlContent, {
      USE_PROFILES: { html: true }, // Use the standard HTML profile (allows common safe tags).
      ADD_TAGS: ["mark"], // Explicitly allow the <mark> tag used by our custom extension.
      // Allow CSS classes used by highlight.js (typically start with 'hljs').
      ALLOWED_CLASSES: {
        // Apply this rule to all tags ('*').
        "*": /^(hljs)(?:-.*)?$/, // Regex allows 'hljs' and 'hljs-...' classes.
      },
    });

    // G.5. Update the content of the HTML preview area with the sanitized HTML.
    htmlOutput.innerHTML = sanitizedHtml;

    // G.6. Re-apply highlight.js to any code blocks *within the newly added preview content*.
    //     This is necessary because inserting HTML via innerHTML doesn't automatically trigger highlight.js.
    htmlOutput.querySelectorAll("pre code").forEach((block) => {
      // Tell highlight.js to find the language (if any) and apply classes to this specific block.
      hljs.highlightElement(block);
    });
  }

  // H. Define the asynchronous function to load the initial Markdown content.
  async function loadMarkdown() {
    // H.1. Try to retrieve content previously saved in localStorage.
    const savedContent = localStorage.getItem(localStorageKey);

    // H.2. Check if content was found in localStorage.
    if (savedContent !== null) {
      // H.2.a. If yes: Load the saved content into the input textarea.
      markdownInput.value = savedContent;
      console.log("Loaded content from localStorage.");
      // H.2.b. Update the preview to reflect the loaded content. (No need to save again here).
      updatePreviewAndSave(); // Call this to render the loaded content
    } else {
      // H.3. If no content in localStorage: Attempt to load from a default file.
      console.log("No content in localStorage, loading from default file.");
      try {
        // H.3.a. Specify the path to the default Markdown file.
        const filePath = "example.md";
        // H.3.b. Fetch the file content asynchronously.
        const response = await fetch(filePath);
        // H.3.c. Check if the fetch request was successful.
        if (!response.ok) {
          // If not successful (e.g., 404 Not Found), throw an error.
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        // H.3.d. Get the text content from the response.
        const markdownText = await response.text();
        // H.3.e. Load the fetched content into the input textarea.
        markdownInput.value = markdownText;
        // H.3.f. Update the preview AND save this initial content to localStorage.
        updatePreviewAndSave();
      } catch (error) {
        // H.4. Handle errors during file fetching (e.g., network error, file not found).
        console.error("Error loading initial Markdown file:", error);
        // H.4.a. Display an error message in the input textarea.
        markdownInput.value = `# Error loading file:\n\n${error.message}\n\nOr no content saved yet. Start typing!`;
        // H.4.b. Update the preview to show the error message (and save the error message to localStorage).
        updatePreviewAndSave();
      }
    }
  }

  // I. Add an event listener to the Markdown input textarea.
  //    This triggers whenever the user types, pastes, or otherwise changes the content.
  markdownInput.addEventListener("input", updatePreviewAndSave);

  // J. Add event listener for the file input element.
  const fileInput = document.getElementById("file-input");
  fileInput.addEventListener("change", (event) => {
    // J.1. Get the selected file (if any) from the event object.
    const file = event.target.files[0];
    // J.2. Proceed only if a file was actually selected.
    if (file) {
      // J.3. Create a FileReader object to read the file content.
      const reader = new FileReader();
      // J.4. Define what happens when the file is successfully read.
      reader.onload = (e) => {
        // J.4.a. Set the input textarea's value to the file content.
        markdownInput.value = e.target.result;
        // J.4.b. Update the preview and save the newly loaded content to localStorage.
        updatePreviewAndSave();
      };
      // J.5. Define what happens if there's an error reading the file.
      reader.onerror = (e) => {
        console.error("Error reading file:", e);
        // J.5.a. Display an error message in the input textarea.
        markdownInput.value = `# Error reading file:\n\n${e.target.error}`;
        // J.5.b. Update the preview to show the error (and save it).
        updatePreviewAndSave();
      };
      // J.6. Start reading the file as plain text.
      reader.readAsText(file);
    }
  });

  // K. Add event listener for the save button.
  const saveButton = document.getElementById("save-button");
  saveButton.addEventListener("click", () => {
    // K.1. Get the current Markdown content from the input textarea.
    const markdownText = markdownInput.value;
    // K.2. Create a Blob (Binary Large Object) containing the Markdown text.
    //     Specify the MIME type as 'text/markdown'.
    const blob = new Blob([markdownText], { type: "text/markdown" });
    // K.3. Create a temporary URL that points to the Blob in memory.
    const url = URL.createObjectURL(blob);
    // K.4. Create a temporary anchor (<a>) element to trigger the download.
    const a = document.createElement("a");
    // K.5. Set the anchor's href to the Blob URL.
    a.href = url;
    // K.6. Set the desired filename for the download.
    a.download = "edited_content.md"; // Consider making this dynamic based on loaded file or date.
    // K.7. Append the anchor to the document (required for click simulation in some browsers).
    document.body.appendChild(a);
    // K.8. Programmatically click the anchor to initiate the download.
    a.click();
    // K.9. Remove the temporary anchor from the document.
    document.body.removeChild(a);
    // K.10. Revoke the temporary Blob URL to free up memory.
    URL.revokeObjectURL(url);
  });

  // L. Call the loadMarkdown function to load initial content when the script runs.
  loadMarkdown();
});
